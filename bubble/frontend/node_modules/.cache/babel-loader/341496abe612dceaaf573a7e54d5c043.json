{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useContext, useMemo } from 'react';\nimport { useDispatch, useSelector, useStore } from 'react-redux';\nimport DataProviderContext from './DataProviderContext';\nimport defaultDataProvider from './defaultDataProvider';\nimport useLogoutIfAccessDenied from '../auth/useLogoutIfAccessDenied';\nimport { getDataProviderCallArguments } from './getDataProviderCallArguments';\nimport { doQuery, stackCall, stackOptimisticCall, getRemainingStackedCalls } from './performQuery';\n/**\n * Hook for getting a dataProvider\n *\n * Gets a dataProvider object, which behaves just like the real dataProvider\n * (same methods returning a Promise). But it's actually a Proxy object, which\n * dispatches Redux actions along the process. The benefit is that react-admin\n * tracks the loading state when using this hook, and stores results in the\n * Redux store for future use.\n *\n * In addition to the 2 usual parameters of the dataProvider methods (resource,\n * payload), the Proxy supports a third parameter for every call. It's an\n * object literal which may contain side effects, or make the action optimistic\n * (with mutationMode: optimistic) or undoable (with mutationMode: undoable).\n *\n * @return dataProvider\n *\n * @example Basic usage\n *\n * import * as React from 'react';\n * import { useState } from 'react';\n * import { useDataProvider } from 'react-admin';\n *\n * const PostList = () => {\n *      const [posts, setPosts] = useState([])\n *      const dataProvider = useDataProvider();\n *      useEffect(() => {\n *          dataProvider.getList('posts', { filter: { status: 'pending' }})\n *            .then(({ data }) => setPosts(data));\n *      }, [])\n *\n *      return (\n *          <Fragment>\n *              {posts.map((post, key) => <PostDetail post={post} key={key} />)}\n *          </Fragment>\n *     );\n * }\n *\n * @example Handling all states (loading, error, success)\n *\n * import { useState, useEffect } from 'react';\n * import { useDataProvider } from 'react-admin';\n *\n * const UserProfile = ({ userId }) => {\n *     const dataProvider = useDataProvider();\n *     const [user, setUser] = useState();\n *     const [loading, setLoading] = useState(true);\n *     const [error, setError] = useState();\n *     useEffect(() => {\n *         dataProvider.getOne('users', { id: userId })\n *             .then(({ data }) => {\n *                 setUser(data);\n *                 setLoading(false);\n *             })\n *             .catch(error => {\n *                 setError(error);\n *                 setLoading(false);\n *             })\n *     }, []);\n *\n *     if (loading) return <Loading />;\n *     if (error) return <Error />\n *     if (!user) return null;\n *\n *     return (\n *         <ul>\n *             <li>Name: {user.name}</li>\n *             <li>Email: {user.email}</li>\n *         </ul>\n *     )\n * }\n *\n * @example Action customization\n *\n * dataProvider.getOne('users', { id: 123 });\n * // will dispatch the following actions:\n * // - CUSTOM_FETCH\n * // - CUSTOM_FETCH_LOADING\n * // - FETCH_START\n * // - CUSTOM_FETCH_SUCCESS\n * // - FETCH_END\n *\n * dataProvider.getOne('users', { id: 123 }, { action: CRUD_GET_ONE });\n * // will dispatch the following actions:\n * // - CRUD_GET_ONE\n * // - CRUD_GET_ONE_LOADING\n * // - FETCH_START\n * // - CRUD_GET_ONE_SUCCESS\n * // - FETCH_END\n */\n\nvar useDataProvider = function () {\n  var dispatch = useDispatch();\n  var dataProvider = useContext(DataProviderContext) || defaultDataProvider; // optimistic mode can be triggered by a previous optimistic or undoable query\n\n  var isOptimistic = useSelector(function (state) {\n    return state.admin.ui.optimistic;\n  });\n  var store = useStore();\n  var logoutIfAccessDenied = useLogoutIfAccessDenied();\n  var dataProviderProxy = useMemo(function () {\n    return new Proxy(dataProvider, {\n      get: function (target, name) {\n        if (typeof name === 'symbol') {\n          return;\n        }\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var _a = getDataProviderCallArguments(args),\n              resource = _a.resource,\n              payload = _a.payload,\n              allArguments = _a.allArguments,\n              options = _a.options;\n\n          var type = name.toString();\n\n          var _b = options || {},\n              _c = _b.action,\n              action = _c === void 0 ? 'CUSTOM_FETCH' : _c,\n              _d = _b.undoable,\n              undoable = _d === void 0 ? false : _d,\n              _e = _b.onSuccess,\n              onSuccess = _e === void 0 ? undefined : _e,\n              _f = _b.onFailure,\n              onFailure = _f === void 0 ? undefined : _f,\n              _g = _b.mutationMode,\n              mutationMode = _g === void 0 ? undoable ? 'undoable' : 'pessimistic' : _g,\n              _h = _b.enabled,\n              enabled = _h === void 0 ? true : _h,\n              rest = __rest(_b, [\"action\", \"undoable\", \"onSuccess\", \"onFailure\", \"mutationMode\", \"enabled\"]);\n\n          if (typeof dataProvider[type] !== 'function') {\n            throw new Error(\"Unknown dataProvider function: \" + type);\n          }\n\n          if (onSuccess && typeof onSuccess !== 'function') {\n            throw new Error('The onSuccess option must be a function');\n          }\n\n          if (onFailure && typeof onFailure !== 'function') {\n            throw new Error('The onFailure option must be a function');\n          }\n\n          if (mutationMode === 'undoable' && !onSuccess) {\n            throw new Error('You must pass an onSuccess callback calling notify() to use the undoable mode');\n          }\n\n          if (typeof enabled !== 'boolean') {\n            throw new Error('The enabled option must be a boolean');\n          }\n\n          if (enabled === false) {\n            return Promise.resolve({});\n          }\n\n          var params = {\n            resource: resource,\n            type: type,\n            payload: payload,\n            action: action,\n            onFailure: onFailure,\n            onSuccess: onSuccess,\n            rest: rest,\n            mutationMode: mutationMode,\n            // these ones are passed down because of the rules of hooks\n            dataProvider: dataProvider,\n            store: store,\n            dispatch: dispatch,\n            logoutIfAccessDenied: logoutIfAccessDenied,\n            allArguments: allArguments\n          };\n\n          if (isOptimistic) {\n            // When in optimistic mode, fetch calls aren't executed\n            // right away. Instead, they are are stacked, to be\n            // executed once the dataProvider leaves optimistic mode.\n            // In the meantime, the admin uses data from the store.\n            if (mutationMode === 'undoable' || mutationMode === 'optimistic') {\n              // optimistic and undoable calls are added to a\n              // specific stack, as they must be replayed first\n              stackOptimisticCall(params);\n            } else {\n              // pessimistic calls are added to the regular stack\n              // and will be replayed last\n              stackCall(params);\n            } // Return a Promise that only resolves when the optimistic call was made\n            // otherwise hooks like useQueryWithStore will return loaded = true\n            // before the content actually reaches the Redux store.\n            // But as we can't determine when this particular query was finished,\n            // the Promise resolves only when *all* optimistic queries are done.\n\n\n            return waitFor(function () {\n              return getRemainingStackedCalls() === 0;\n            });\n          } else {\n            return doQuery(params);\n          }\n        };\n      }\n    });\n  }, [dataProvider, dispatch, isOptimistic, logoutIfAccessDenied, store]);\n  return dataProviderProxy;\n}; // get a Promise that resolves after a delay in milliseconds\n\n\nvar later = function (delay) {\n  if (delay === void 0) {\n    delay = 100;\n  }\n\n  return new Promise(function (resolve) {\n    setTimeout(resolve, delay);\n  });\n}; // get a Promise that resolves once a condition is satisfied\n\n\nvar waitFor = function (condition) {\n  return new Promise(function (resolve) {\n    return condition() ? resolve() : later().then(function () {\n      return waitFor(condition).then(function () {\n        return resolve();\n      });\n    });\n  });\n};\n\nexport default useDataProvider;","map":{"version":3,"sources":["/node_modules/ra-core/esm/dataProvider/useDataProvider.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","useContext","useMemo","useDispatch","useSelector","useStore","DataProviderContext","defaultDataProvider","useLogoutIfAccessDenied","getDataProviderCallArguments","doQuery","stackCall","stackOptimisticCall","getRemainingStackedCalls","useDataProvider","dispatch","dataProvider","isOptimistic","state","admin","ui","optimistic","store","logoutIfAccessDenied","dataProviderProxy","Proxy","get","target","name","args","_i","arguments","_a","resource","payload","allArguments","options","type","toString","_b","_c","action","_d","undoable","_e","onSuccess","undefined","_f","onFailure","_g","mutationMode","_h","enabled","rest","Error","Promise","resolve","params","waitFor","later","delay","setTimeout","condition","then"],"mappings":"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","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { useContext, useMemo } from 'react';\nimport { useDispatch, useSelector, useStore } from 'react-redux';\nimport DataProviderContext from './DataProviderContext';\nimport defaultDataProvider from './defaultDataProvider';\nimport useLogoutIfAccessDenied from '../auth/useLogoutIfAccessDenied';\nimport { getDataProviderCallArguments } from './getDataProviderCallArguments';\nimport { doQuery, stackCall, stackOptimisticCall, getRemainingStackedCalls, } from './performQuery';\n/**\n * Hook for getting a dataProvider\n *\n * Gets a dataProvider object, which behaves just like the real dataProvider\n * (same methods returning a Promise). But it's actually a Proxy object, which\n * dispatches Redux actions along the process. The benefit is that react-admin\n * tracks the loading state when using this hook, and stores results in the\n * Redux store for future use.\n *\n * In addition to the 2 usual parameters of the dataProvider methods (resource,\n * payload), the Proxy supports a third parameter for every call. It's an\n * object literal which may contain side effects, or make the action optimistic\n * (with mutationMode: optimistic) or undoable (with mutationMode: undoable).\n *\n * @return dataProvider\n *\n * @example Basic usage\n *\n * import * as React from 'react';\n * import { useState } from 'react';\n * import { useDataProvider } from 'react-admin';\n *\n * const PostList = () => {\n *      const [posts, setPosts] = useState([])\n *      const dataProvider = useDataProvider();\n *      useEffect(() => {\n *          dataProvider.getList('posts', { filter: { status: 'pending' }})\n *            .then(({ data }) => setPosts(data));\n *      }, [])\n *\n *      return (\n *          <Fragment>\n *              {posts.map((post, key) => <PostDetail post={post} key={key} />)}\n *          </Fragment>\n *     );\n * }\n *\n * @example Handling all states (loading, error, success)\n *\n * import { useState, useEffect } from 'react';\n * import { useDataProvider } from 'react-admin';\n *\n * const UserProfile = ({ userId }) => {\n *     const dataProvider = useDataProvider();\n *     const [user, setUser] = useState();\n *     const [loading, setLoading] = useState(true);\n *     const [error, setError] = useState();\n *     useEffect(() => {\n *         dataProvider.getOne('users', { id: userId })\n *             .then(({ data }) => {\n *                 setUser(data);\n *                 setLoading(false);\n *             })\n *             .catch(error => {\n *                 setError(error);\n *                 setLoading(false);\n *             })\n *     }, []);\n *\n *     if (loading) return <Loading />;\n *     if (error) return <Error />\n *     if (!user) return null;\n *\n *     return (\n *         <ul>\n *             <li>Name: {user.name}</li>\n *             <li>Email: {user.email}</li>\n *         </ul>\n *     )\n * }\n *\n * @example Action customization\n *\n * dataProvider.getOne('users', { id: 123 });\n * // will dispatch the following actions:\n * // - CUSTOM_FETCH\n * // - CUSTOM_FETCH_LOADING\n * // - FETCH_START\n * // - CUSTOM_FETCH_SUCCESS\n * // - FETCH_END\n *\n * dataProvider.getOne('users', { id: 123 }, { action: CRUD_GET_ONE });\n * // will dispatch the following actions:\n * // - CRUD_GET_ONE\n * // - CRUD_GET_ONE_LOADING\n * // - FETCH_START\n * // - CRUD_GET_ONE_SUCCESS\n * // - FETCH_END\n */\nvar useDataProvider = function () {\n    var dispatch = useDispatch();\n    var dataProvider = useContext(DataProviderContext) || defaultDataProvider;\n    // optimistic mode can be triggered by a previous optimistic or undoable query\n    var isOptimistic = useSelector(function (state) { return state.admin.ui.optimistic; });\n    var store = useStore();\n    var logoutIfAccessDenied = useLogoutIfAccessDenied();\n    var dataProviderProxy = useMemo(function () {\n        return new Proxy(dataProvider, {\n            get: function (target, name) {\n                if (typeof name === 'symbol') {\n                    return;\n                }\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var _a = getDataProviderCallArguments(args), resource = _a.resource, payload = _a.payload, allArguments = _a.allArguments, options = _a.options;\n                    var type = name.toString();\n                    var _b = options || {}, _c = _b.action, action = _c === void 0 ? 'CUSTOM_FETCH' : _c, _d = _b.undoable, undoable = _d === void 0 ? false : _d, _e = _b.onSuccess, onSuccess = _e === void 0 ? undefined : _e, _f = _b.onFailure, onFailure = _f === void 0 ? undefined : _f, _g = _b.mutationMode, mutationMode = _g === void 0 ? undoable ? 'undoable' : 'pessimistic' : _g, _h = _b.enabled, enabled = _h === void 0 ? true : _h, rest = __rest(_b, [\"action\", \"undoable\", \"onSuccess\", \"onFailure\", \"mutationMode\", \"enabled\"]);\n                    if (typeof dataProvider[type] !== 'function') {\n                        throw new Error(\"Unknown dataProvider function: \" + type);\n                    }\n                    if (onSuccess && typeof onSuccess !== 'function') {\n                        throw new Error('The onSuccess option must be a function');\n                    }\n                    if (onFailure && typeof onFailure !== 'function') {\n                        throw new Error('The onFailure option must be a function');\n                    }\n                    if (mutationMode === 'undoable' && !onSuccess) {\n                        throw new Error('You must pass an onSuccess callback calling notify() to use the undoable mode');\n                    }\n                    if (typeof enabled !== 'boolean') {\n                        throw new Error('The enabled option must be a boolean');\n                    }\n                    if (enabled === false) {\n                        return Promise.resolve({});\n                    }\n                    var params = {\n                        resource: resource,\n                        type: type,\n                        payload: payload,\n                        action: action,\n                        onFailure: onFailure,\n                        onSuccess: onSuccess,\n                        rest: rest,\n                        mutationMode: mutationMode,\n                        // these ones are passed down because of the rules of hooks\n                        dataProvider: dataProvider,\n                        store: store,\n                        dispatch: dispatch,\n                        logoutIfAccessDenied: logoutIfAccessDenied,\n                        allArguments: allArguments,\n                    };\n                    if (isOptimistic) {\n                        // When in optimistic mode, fetch calls aren't executed\n                        // right away. Instead, they are are stacked, to be\n                        // executed once the dataProvider leaves optimistic mode.\n                        // In the meantime, the admin uses data from the store.\n                        if (mutationMode === 'undoable' ||\n                            mutationMode === 'optimistic') {\n                            // optimistic and undoable calls are added to a\n                            // specific stack, as they must be replayed first\n                            stackOptimisticCall(params);\n                        }\n                        else {\n                            // pessimistic calls are added to the regular stack\n                            // and will be replayed last\n                            stackCall(params);\n                        }\n                        // Return a Promise that only resolves when the optimistic call was made\n                        // otherwise hooks like useQueryWithStore will return loaded = true\n                        // before the content actually reaches the Redux store.\n                        // But as we can't determine when this particular query was finished,\n                        // the Promise resolves only when *all* optimistic queries are done.\n                        return waitFor(function () { return getRemainingStackedCalls() === 0; });\n                    }\n                    else {\n                        return doQuery(params);\n                    }\n                };\n            },\n        });\n    }, [dataProvider, dispatch, isOptimistic, logoutIfAccessDenied, store]);\n    return dataProviderProxy;\n};\n// get a Promise that resolves after a delay in milliseconds\nvar later = function (delay) {\n    if (delay === void 0) { delay = 100; }\n    return new Promise(function (resolve) {\n        setTimeout(resolve, delay);\n    });\n};\n// get a Promise that resolves once a condition is satisfied\nvar waitFor = function (condition) {\n    return new Promise(function (resolve) {\n        return condition()\n            ? resolve()\n            : later().then(function () { return waitFor(condition).then(function () { return resolve(); }); });\n    });\n};\nexport default useDataProvider;\n"]},"metadata":{},"sourceType":"module"}